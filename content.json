{"meta":{"title":"sfloat的博客","subtitle":"阻止成长的不是无知，而是傲慢与偏见","description":null,"author":"sfloat","url":"https://nodesoya.github.io"},"pages":[{"title":"","date":"2017-05-17T02:45:23.255Z","updated":"2017-05-17T02:45:23.255Z","comments":false,"path":"categories/index.html","permalink":"https://nodesoya.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-17T02:45:38.716Z","updated":"2017-05-17T02:45:38.716Z","comments":false,"path":"tags/index.html","permalink":"https://nodesoya.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端武林之十招设计模式","slug":"前端武林之十招设计模式","date":"2017-07-30T03:44:49.000Z","updated":"2017-07-30T09:34:17.539Z","comments":true,"path":"2017/07/30/前端武林之十招设计模式/","link":"","permalink":"https://nodesoya.github.io/2017/07/30/前端武林之十招设计模式/","excerpt":"","text":"概述天下武功，唯快不破，而习武却止于形者，往往套路舞到完，拳头吃到饱。我们不仅要知其然，更要知其所以然。下面我们就一起来剖析前端武林的十招设计模式，每招设计模式分为：描述、剖析、类比三个部分，类比主要来自少林寺场景，方便大家理解。 第一式：单例模式 描述：保证一个类只有一个实例 剖析为的是去除重复实例化类的性能冗余或空间冗余。DOM的创建过程也同样适用。 类比练拳需要沙袋，如果每次练都挂一个沙袋，不仅空间浪费，还耗时费力 第二式：构造函数模式 描述：构造函数用于创建特定类型对象，可接受参数设置对象成员值，自定义的属性和方法 剖析为的是去除兄弟类之间相同方法的冗余。将不同的属性、方法的构建封装在构造函数中，产出不同的对象 类比大师兄和二师兄练铁砂掌都需要灶台、锅、沙子，大师兄功力强要更烫、更细的沙子，但不会为两个师兄弟分别做一个灶台，而是谁要练就换自己需要的沙子 第三式：工厂模式 描述：工厂模式定义一个用于创建对象的接口，该接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类 剖析对于功能相似的类，往往我们需要根据环境进行选择性的实例化。而工厂模式就是将这个选择过程封装起来，统一接口。 类比寺内轮流值班扫地，如果每次临时确定谁值班必然耗时费力，所以需要由一个人统一规划，大家不懂就只管问他。 第四式：代理模式 描述：为其他对象提供一种代理以控制对这个对象的访问。 剖析对象对外访问有时候需要进行进一步加强，比如安全校验、跨域能力。而代理模式就是将加强部分进行封装和划分，方便后期维护。 类比师傅年纪大了，腿脚不利索，访问武当，峨眉的这些重活累活只能交给徒弟，为了方便后面一起传授访问技巧，而不是一个个去教，需要把这些徒弟聚在一起组成徒弟代理团 第五式：建造者模式 描述：建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 剖析建造者模式主要用于复杂的场景，将一个复杂的模块分成多个子模块，进行不同的组装，以增加子模块的复用，防止不同组装时子模块冗余 类比十八罗汉阵阵型变化多端，但是无论怎么变需要的只是十八个人，而不会每变一次就换一批人 第六式：命令模式 描述：用来对方法调用进行参数化处理和传送，经过这样处理过后的方法可以在任何需要的时候执行 剖析将多个功能封装起来，划分进入一个对象，然后通过传入的命令参数实现不同功能的执行。降低了对这个对象的维护成本，和他人使用这个对象时的学习成本 类比师傅要每天要从后勤找一个人下山挑水，但是人老了记性不好，每次叫人都记不住名字，干脆就让后勤自己确定谁去挑水，师傅只管下一声命令：挑水 第七式：观察者模式 描述：观察者模式又叫发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象 剖析这是一个改变触发位置的模式，正常我们在哪里需要触发事件，往往会在当前类直接调用触发，而观察这模式就是将这个触发的位置转移到了被触发的类，解耦两个类，方便后期维护 类比习武场上，师傅年迈，精力有限，不会一个个主动去指点，而是让徒弟碰到不懂的自己过去问 第八式：适配器模式 描述：适配器模式是将一个类（对象）的接口（方法或属性）转换成客户希望的另外一个接口 剖析这个和代理模式有点像，只是划分的内容不同。适配器模式是将两个对象在连接时做的兼容部分划分出来，方便后期的维护。 类比武当和少林时常有往来，但是每次交流都会碰到习惯，作息等不同带来的麻烦。为了交流方便，在中间建立一个亭子，方便双方的沟通交流 第九式：职责链模式 描述：职责链模式是使多个对象都有机会处理请求，从而避免请求发送者和接受者之前的耦合关系 剖析将一个处理流程划分多个模块，组成一个流程链，方便对流程的每个环节进行维护。 类比一个消息过来少林寺，由执事、班首、监寺、方丈，层层传递，直到有一个最合适的处理人，而且职责分明也方便了人员调配 第十式：迭代器模式 描述：迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该方法的内部表示 剖析将遍历方法划入对象内部，提升遍历代码的复用度。 类比师傅需要知道武僧团有多少人，会让每个人报数，而不是一个个去数。自己数的话每换一个师傅就得数一遍，而报数是由武僧团来完成的 总结综上可以看出十招设计模式主要做的两个事：去冗余和划分模块，大家可以想想十个中哪些主要去了冗余，而哪些主要划分了模块。而去冗余提升了性能，划分模块降低了维护成本。这也是设计模式存在的意义，提升项目的性价比。 代码演练该部分通过代码实现以下场景：师傅让大师兄或小师弟去练铁砂掌 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 构造函数模式 + 单例模式 + 命令模式 * 去除冗余 + 划分模块 */ // 构造器 function Boxing (name, temperature, fineness, speakFunc) &#123; this.name = name this.temperature = temperature this.fineness = fineness this.speak = speakFunc &#125; Boxing.prototype.begin = function () &#123; this.speak() console.log('温度：' + this.temperature + '；沙子细度：' + this.fineness + '；') &#125; Boxing.prototype.end = function () &#123; var date = new Date() console.log(date + this.name + '练拳结束') &#125; var bigBrother, smallBrother function masterCall (name) &#123; if (name === '大师兄') &#123; // 单例判断 if (bigBrother === undefined) &#123; bigBrother = new Boxing('大师兄', '80度', '2mm', function () &#123; console.log('我是师兄，就用打印吧，开始练拳') &#125;) &#125; bigBrother.begin() bigBrother.end() &#125; if (name === '小师弟') &#123; if (smallBrother === undefined) &#123; smallBrother = new Boxing('小师弟', '60度', '6mm', function () &#123; alert('我是小师弟，但我要弹窗，开始练拳') &#125;) &#125; smallBrother.begin() smallBrother.end() &#125; &#125; // 命令执行 masterCall('大师兄') masterCall('小师弟')","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://nodesoya.github.io/categories/系统优化/"}],"tags":[]},{"title":"JavaScript的表现力来源","slug":"JavaScript的表现力来源","date":"2017-05-19T09:45:20.000Z","updated":"2017-05-19T12:08:54.685Z","comments":true,"path":"2017/05/19/JavaScript的表现力来源/","link":"","permalink":"https://nodesoya.github.io/2017/05/19/JavaScript的表现力来源/","excerpt":"","text":"适读人群：想对JavaScript做深入了解的前端工程师 概述JavaScript是一门灵活且有表现力的语言，当然灵活也带来了很多坑。那么JavaScript的表现力核心在哪里呢？我认为主要有三个地方：this，作用域，原型链。 一．This相信大家对This并不陌生，This是一个指向对象的指针，往往谁调它它指谁。而调用的环境是多变的，也就带来了this指向的灵活。 默认this的指向是global。如下：1234567891011121314151617var a = 38function showNumber () &#123; var a = 1 console.log(this.a)&#125;showNumber() // 输出：38，this指向为globalfunction showAll() &#123; var a = 183 var showNumber = function () &#123; console.log(this.a) &#125; return showNumber()&#125;showAll() // 输出：38，即时在函数内，没有定义为对象属性调用该函数的依旧是global 如果调用函数的是某对象时，则函数内的this指向该对象。如下：12345678910var a = 38function showNumber () &#123; var a = 1 console.log(this.a)&#125;var methodsObj = &#123;a: 110&#125;methodsObj.showNumber = showNumbermethodsObj.showNumber() // 输出：110，因为调用该函数的是methodsObjnew showNumber() // 输出：undefined，new构造了新的对象，调用函数的是新对象 This不仅有默认的指向，而且它是可以设置的，通过call，apply即可设置。从而实现两个对象的弱连接，得以共享数据和方法。如下：1234567function add() &#123; console.log(this.a + this.b)&#125;var dataObj = &#123;a: 110, b: 200&#125;add.call(dataObj) // 输出：310 上面这个例子中，对于对象dataObj来说是共享了global的方法add，处理了自己的数据。而对于global则是共享了dataObj的数据，让global的方法得以获取。 二．作用域直接讲作用域可能大家是陌生的，但闭包大家一定不陌生，而闭包的原理就在作用域上。JS是中最小的作用域单位是函数，所以带来了闭包，闭包在多种场景中都有使用，比如私有变量，块作用域等。如下：123456789101112131415161718192021222324252627/* 私有变量 */function addFactory() &#123; var a = 110, b = 330 return function () &#123; a = a+8 console.log(a + b) &#125;&#125;var add = addFactory()add() // 输出：448add() // 输出：456，a变量作为add的私有变量，外部不可见/* 块作用域 */for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i) // 输出：五个5 &#125;, 100)&#125;for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function () &#123; console.log(i) // 输出：0,1,2,3,4，因为闭包封装了一块作用域，使其不受外部变量影响 &#125;, 100) &#125;)(i)&#125; 而且函数内声明的变量真实的执行顺序是在顶部，因为无需考虑块作用域的情况。如下：1234567891011121314151617181920 function test() &#123; console.log(a) console.log(foo()) var a = 1 function foo() &#123; return 2 &#125; &#125; test() // 输出：undefined，2// 上述test函数相当于 function test() &#123; var a function foo() &#123; return 2 &#125; console.log(a) console.log(foo()) a = 1 &#125; 三．原型链原型链是js类继承的实现方式，通过原型链实现了js对象的强连接，让this直接调用父对象的属性。如下：12345678910111213function Animal() &#123; this.name = 'haki'&#125;Animal.prototype.speak = function () &#123; console.log(this.name + ' is ' + this.age + ' years old')&#125;function People() &#123; this.age = '33'&#125;People.prototype = new Animal()var person = new People()person.speak() // haki is 33 years old 上面的例子中People通过prototype和new实现了继承Animal，而这个过程是怎么实现的呢？主要是两步：1.将prototype指向需要继承的对象2.通过new实例化对象(创建新对象-&gt;_proto_指向prototype-&gt;执行构造函数) 结语以上就是我认为JavaScript表现力的来源，这些特性带来了灵活性，但是用的不好也会导致代码的不易维护，所以在现实场景中怎么根据需求活学活用是很重要的","categories":[{"name":"语言本身","slug":"语言本身","permalink":"https://nodesoya.github.io/categories/语言本身/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nodesoya.github.io/tags/JavaScript/"}]},{"title":"六步搞定组件化单页面","slug":"六步搞定组件化单页面","date":"2017-05-17T07:39:52.000Z","updated":"2017-05-18T07:41:22.114Z","comments":true,"path":"2017/05/17/六步搞定组件化单页面/","link":"","permalink":"https://nodesoya.github.io/2017/05/17/六步搞定组件化单页面/","excerpt":"","text":"适读人群：1.具备工程化思维的前端2.想了解现阶段前后端的合作方式的后端 概述文章以单页面为核心阐述它的实现过程，里面涉及概念的东西不多，因为考虑到讲概念去对大家帮助不大，而且这些概念随手百度google都可以找到。所以文章主要从大体步骤的角度简单讲讲的是我是如何将OA重构成组件化单页面应用，并且实现通过配置完成新流程的动态添加的。希望大家读完后能对此类项目有个基本的实现思路 第一步：制定组件标准 TIPS：车在组装各零件之前，得先将各个零件规范起来，不能这个轮子1m长那个轮子1.2m的，这样就四不像了。 实现组件化的前提是得标准化。怎么完成标准化呢？大概步骤可分为三步：1.以重用度为标准归纳和分类各组件。而组件中主要分为两种：通用组件和业务组件，通用组件如弹窗、按钮、时间插件等，业务组件如顶部个人信息，机票块信息等跟业务相关的组件。2.将归纳出来的组件进行设计，统一风格。3.根据UI给的设计图编写组件库。类似微信的WeUI，我也写了一个OAUI，并且提供了人性化的错误提示和单页面适配。网址：http://oaui.yucow.com如下图： 第二步：单页面框架选型 TIPS：生厂一类汽车，该让什么厂生产呢？大厂快但是耗费多，小厂耗费少但是慢，怎么选？这个时候就需要根据我们的需求场景来选择一个合适的，如果量大时间紧果断大厂送过去，如果钱少周期长，小厂也很稳健。 组件标准梳理完成后，下一步就是考虑用什么框架组装了，也就是单页面框架选型。现在可供选择的单页面框架不少，比如Vue，React，Angular2, Ember, Polymer等，而其中Vue, React，Angular最受欢迎。最终我选择的是Vue。为什么选它呢？我们先讲讲Angular2，Angular2的目标是一套企业级的解决方案，从它用Typescript这种规范性比较强的官方语言就可以看出，是比较重的。而React呢，Vue和React都用的虚拟Dom，性能都非常快，所以对于这两个我主要考虑的也是入手的门槛。React提倡just javascript，模板编写很灵活，但JavaScript里的HTMl和CSS会产生很多痛点，灵活有时候会写出凌乱的render，而且JSX的使用也增加了学习成本。但是这样的比较很感官，做出的判断不准确，这里我说一个选择的方法。就和我们去菜市场买菜一样，哪个性价比高买哪个，选择框架也一样。性指的是性能，价指的是成本，而框架的成本主要是学习成本和开发维护成本。我们针对这三个框架列一个对比表： 框架/基于轻应用场景成本性能/耗时学习成本开发维护成本Vue低低快（1.37）React中低较快（1.82）Angular2高中较快（1.85） 上面这个表格可以让我们轻松做出选择，不过表格里面的内容不是固定不变的，也会根据特定的场景改变，比如react的社区生态是最繁荣的，里面的各种解决方案也很多，如果里面有刚好适合你的业务场景的，那么对应的就可以降低开发成本。对于Vue，往往也需要搭配了Vue-router和Vuex。也就是单页面三件套：核心解析，路由，状态管理。Vue和React都有对应的脚手架帮你搭建初始的工程化环境，里面配套了热加载，代码规范检测，单元测试，端对端测试等 第三步：组件划分 TIPS：对于一辆汽车，四个轮子都是一样的，肯定直接给一个流水线组。而前盖和后盖呢？可能前盖需要完美线条，后盖不需要，那么要到两个流水线组。但对于前盖和后盖都是粗线条的，如果分成两个流水线组，因为用的技术都差不多，对应的技术人员要在两个流水线来回跑，就浪费时间了。 对于单页面应用，页面也是一个组件，而每个组件中又有很多的子组件。对于组件的划分，优先级最高的是页面组件，而且以相似度为标准进行划分，如果两个相似程度不高的内容放在一个组件中只会徒增判断维护成本。而两个相似度高的内容放在不同组件也会增加数据维护成本，所以要让成本降到最低就得有合理的组件划分。比如下面的两个页面组件（每个页面组件中有多个子组件，但我们现在只考虑页面组件）： 它们相似度很高，如果划为不同组件页面，有些地方一修改就是都要修改，比如数据筛选处理，这样就增加了不必要的维护成本。将其整合到一个组件中，成本一下就下来了 第四步：状态结构设计 TIPS：汽车流水线中，每个零件的顺序会影响组装的速度，而组装的过程中又不断的改进零件顺序 每个单页面都有全局状态，比如地理位置之类的，我们也可以称之为缓存。对于全局状态，Vue有它官方的状态管理插件Vuex，而这部分讲的是被管理数据状态的结构。数据结构决定程序！而单页面中全局状态结构对程序影响是很大的。拿OA中列表的状态结构来说，请假列表在异步批量办理时，用户可能返回导航，进入详情页等，所以需要保存状态。对于保存方法大家可能很容易就想到了列表栈，这是一种方法。但是对于列表除了批量还有其他状态，比如滚动的位置，列表的内容，搜索标题等。如果采用独立栈的方式，会带来每次进入列表时对栈进行匹配判断的开销。如果将结构改为树结构，然后用一个指针指向对应树节点，这样的话每个节点相互独立，不仅减少了维护成本，而且代码优雅简洁 第五步：开发实践 TIPS：图纸画好，方案确定，流水线也规划完成，剩下的就是开工了，打磨的打磨，清洗的清洗。 组件前面我们组件标准制定的时候有提到组件分为两种：通用组件和业务组件，这两种组件在我们实际的开发中应用方式是不一样的。 1．通用组件是一个独立封装的库，和Vue还是单页面都没有关联，可平滑移植到不同的项目，调用方式也只需一个函数接口进行调用，比如弹窗，时间选择，确认选择等，如下图： 2．业务组件是针对当前项目的组件，每个页面模块也是一个组件，而组件中又会有很多子组件子组件和父组件可以通过prop，slot等方式进行通信。 而每个组件都有自己的生命周期，有：beforeCreate,created,beforeMount,mounted等，实际开发中可以根据自己的需要在不同的阶段做对应的操作，以列表页组件为例，大致的周期如图： 可配置化OA现在移动端已实现通过配置实现流程的新增修改： 实现主要靠三个部分：配置信息，特殊处理库和结构解析器1.配置信息：配置信息是页面结构的依据，修改配置信息也就修改了页面结构。而页面的结构可能有判断，循环，或判断和循环相互嵌套。所以配置信息需要根据页面结构进行设计，同时考虑解析的问题2.特殊处理库(适配器)：对于组件我们可以统一处理，但是对于非组件，或需要进行加工的源数据，就需要特殊处理了。而在调用特殊处理接口时建议使用APPLY或CALL，方便和模块共用一套参数3.结构解析器：配置结构是多层的，每层大致可分为行、判断、循环三种块。对于这种复杂的结构，使用简单的循环肯定走不通，必须使用递归和决策树的方式进行层层解析，然后行解析、单元解析，其中注意使用正则做字符串匹配总体结构如图： 第六步：测试 TIPS：车的生产要有质量保证，就必须进行测试。有细致的测试比如量量轮子，敲敲玻璃。也可以整体的测试，比如开到沙漠，开到沼泽。 每一个产品生产出来都离不开测试，不过我这一步讲的不是交给测试人员进行测试，而是在此之前，开发人员做的测试。在前端还是简单切页面的时候，是基本不需要测试的，也没那个必要。而随着前端越来越重，单页面的逻辑也越来越复杂，复杂要想保证质量的话就必须进行测试。现在前端的测试主要有两个：单元测试和端对端测试。端对端测试是一个整体的测试，移动端应用使用端对端测试的必要性不大，而PC上需要兼容不同浏览器的时候比较用得上，VUE官方标配的端对端测试框架是nightWatch，而市面上还有casperJS,protractor等。单元测试是一种比较细致的测试，我们可以进行有目的的测试，比如涉及一些数据处理的单元就很适合也有必要做单元测试，测试的节奏也可以根据自己的情况安排，既可以边开发边测试也可以开发完后再测试，单元测试Vue的官方标配是karma+mocha，当然除了mocha你还可以用jasmine等，测试完成后可以用网页查看覆盖率。如图： 最后完成了以上六步也就完成了一个组件化单页面应用了，大家看了这六步会发现我花了不少的时间在前期的选型和结构设计上，而我觉得这个是非常有必要的，一个好的选型和结构会让你在后期事半功倍，这是性价比很高的投入。合理的投入才能有合理的产出，希望大家看完后文章能在组件化单页面的开发中将投入达到更合理","categories":[{"name":"架构","slug":"架构","permalink":"https://nodesoya.github.io/categories/架构/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://nodesoya.github.io/tags/Vue/"},{"name":"组件化","slug":"组件化","permalink":"https://nodesoya.github.io/tags/组件化/"},{"name":"可配置","slug":"可配置","permalink":"https://nodesoya.github.io/tags/可配置/"}]}]}